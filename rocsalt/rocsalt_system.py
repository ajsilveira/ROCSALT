"""
rocsalt_system.py
Open source toolkit for creating an OpenMM System_ and ParmEd Structure_ for a receptor and pair of compounds screened in ROCS (<https://www.eyesopen.com/rocs >)
.. _System : http://docs.openmm.org/latest/api-python/generated/simtk.openmm.openmm.System.html.
.. _Structure : https://parmed.github.io/ParmEd/html/api/parmed/parmed.structure.html?highlight=structure#module-parmed.structu
"""

import os
import copy
import time
import yaml
import shutil
import logging
import pickle
import pathlib
import argparse
import itertools
import progressbar
import ruamel.yaml

import mdtraj as md
import parmed as pmd
import mdtraj.utils

from simtk import openmm, unit
from simtk.openmm import app
from simtk.openmm import XmlSerializer

import random
import numpy as np
from math import floor

import yank
import openmmtools as mmtools
import openmoltools
from openmoltools.utils import getoutput
from openmmtools import forces, states
from openmoltools import utils, amber


class RocsaltSystem(object):
    """
    OpenMM System_ and ParmEd Structure_ for a Rocsalt simulation.
    .. _System : http://docs.openmm.org/latest/api-python/generated/simtk.openmm.openmm.System.html
    .. _Structure : https://parmed.github.io/ParmEd/html/api/parmed/parmed.structure.html?highlight=structure#module-parmed.structu

    Parameters
    ----------
        ligand_1_file : str
            Mol2 file of ligand 1.
        ligand_1_file : str
            Mol2 file of ligand 2.
        receptor_file1 [, receptor_file2] : str
            Prmtop/inpcrd or pdb files of receptor.

    Properties
    ----------
        ligands : list(Ligand)
        phases: list(Phases)

    """
    def __init__(self, ligand_1_file, ligand_2_file, *receptor_files):

        self.ligands = []
        self.phases = []

        # kwargs for creating a minimal periodic OpenMM system
        # rigidWater False is required for ParmEd to get water parameters
        kwargs = { 'nonbondedMethod' : app.PME, 'rigidWater' : False}
        # Determine the source of receptor file by the size of the list
        if len(receptor_files) == 1:
            system, topo, xyz, charge = self._system_from_pdb(receptor_files[0],
                                                              **kwargs)
        elif len(receptor_files) == 2:
            system, topo, xyz, charge = self._system_from_amber(*receptor_files,
                                                                **kwargs)

        # Raise an error if system is not neutral
        if charge != 0:
            raise(ValueError('Must provide a NEUTRAL receptor system.'))

        # Initiate complex phase
        self.phases.append(_Phase(pmd.openmm.load_topology(topo, system=system,
                                                          xyz=xyz)))

        # TODO: automatically handle the shift in coordinates generated by tleap when solvating the system
        if len(receptor_files) == 2:
            center = self.phases[0].structure.get_coordinates(frame=0).mean(0)
            xyz = self.phases[0].structure.get_coordinates(frame=0)
            self.phases[0].structure.coordinates =  xyz - center

        # Directory for prmtop/inpcrd and tleap log files
        is_data = os.path.exists(os.getcwd() + '/data')
        if not is_data:
            os.mkdir('data')

        # Assign arbitrary resnames
        resnames = ['l1', 'l2']

        for index, file in enumerate([ligand_1_file, ligand_2_file]):
            prmtop_file, inpcrd_file = self._ligand_amber_files(resnames[index],
                                                                    file)
            prm = pmd.amber.AmberParm(prmtop_file)
            total_charge = int(floor(0.5 + pmd.tools.netCharge(prm).execute()))
            self.phases[0].structure += pmd.load_file(prmtop_file, xyz=inpcrd_file)
            complex_top = self.phases[0].structure.topology
            lig_res = f'resname {resnames[index]}'
            lig_idx = md.Topology.from_openmm(complex_top).select(lig_res).tolist()
            # properties carried by each ligand
            self.ligands.append(_Ligand(resnames[index], total_charge,
                                 sorted(lig_idx)))

        # Create solvent box containing the ligands and counterions
        prmtop_file, inpcrd_file = self._solvent_amber_files(f'{resnames[0]}',
                                                        f'data/{resnames[0]}.gaff.mol2',
                                                        f'data/{resnames[0]}.frcmod',
                                                        'data/solvent.prmtop',
                                                        'data/solvent.inpcrd')
        # Initiate solvent phase
        self.phases.append(_Phase(pmd.load_file('data/solvent.prmtop',
                                   xyz='data/solvent.inpcrd')))
        # tleap shifts coordinates: recenter before adding ligand 2
        center = self.phases[1].structure.get_coordinates(frame=0).mean(0)
        self.phases[1].coordinates = self.phases[1].structure.get_coordinates(frame=0) - center
        self.phases[1].structure += pmd.load_file(f'data/{resnames[1]}.prmtop',
                                                  xyz=f'data/{resnames[1]}.inpcrd')

        for index, phase in enumerate(['complex', 'solvent']):
            system = self.phases[index].create_system()
            mdtraj_topo = md.Topology.from_openmm(self.phases[index].structure.topology)
            lig1_idx = mdtraj_topo.select(f'resname {self.ligands[0].name}').tolist()
            lig2_idx = mdtraj_topo.select(f'resname {self.ligands[1].name}').tolist()
            ions_atoms = self.phases[index].ions_atoms(self.phases[index].structure.topology)
            ions_net_charges = [(ion_id, yank.pipeline.compute_net_charge(system, [ion_id]))
                                for ion_id in ions_atoms]
            ignore = [ions[0] for ions in ions_net_charges] + lig1_idx + lig2_idx
            indices = [atom.index for atom in mdtraj_topo.atoms if atom.index not in ignore]
            net_charge = yank.pipeline.compute_net_charge(system, indices)
            charge_init = net_charge + yank.pipeline.compute_net_charge(system, lig1_idx)
            charge_end = net_charge + yank.pipeline.compute_net_charge(system, lig2_idx)
            if (charge_init*charge_end) > 0:
                if abs(charge_init) > abs(charge_end):
                    ions_to_dummies = int(charge_end - charge_init)
                    dummies_to_ions = None
                elif abs(charge_init) < abs(charge_end):
                    ions_to_dummies = None
                    dummies_to_ions = int(-(charge_end - charge_init))
                else:
                    ions_to_dummies = None
                    dummies_to_ions = None
            else:
                ions_to_dummies = int(-charge_init)
                dummies_to_ions = int(-charge_end)

            counterions = yank.pipeline.ions_subset(ions_net_charges, -charge_init)
            avail_ions = [id for id in ions_net_charges if id not in counterions]
            ions_to_dummies_idx = None
            dummies_to_ions_idx = None
            if ions_to_dummies:
                ions_to_dummies_idx = counterions[:abs(ions_to_dummies)]
            if dummies_to_ions:
                dummies_to_ions_idx = ions_subset(avail_ions, dummies_to_ions)

            keep_ions = []
            if ions_to_dummies:
                self.phases[index].ions_to_dummies_idx = counterions[:abs(ions_to_dummies)]
                keep_ions.append(self.phases[index].ions_to_dummies_idx)
            if dummies_to_ions:
                self.phases[index].dummies_to_ions_idx = self.phases[index].yank.pipeline.ions_subset(avail_ions,
                                                                          dummies_to_ions)
                keep_ions.append(self.phases[index].dummies_to_ions_idx)
            keep_ions += counterions
            self.phases[index].to_dummies_idx = [id for id in ions_atoms if id not in keep_ions]
            amber_mask = '@' + ', '.join(str(x + 1) for x in self.phases[index].to_dummies_idx)
            self.phases[index].structure.strip(amber_mask)
            new_mdtraj_topo = md.Topology.from_openmm(self.phases[index].structure.topology)
            self.phases[index].system = self.phases[index].create_system()
            self.phases[index].lig1_idx = new_mdtraj_topo.select(f'resname {self.ligands[0].name}').tolist()
            self.phases[index].lig2_idx = new_mdtraj_topo.select(f'resname {self.ligands[1].name}').tolist()
        
        # anneal complex phase to avoid clashes
        positions = self._anneal_ligand(self.phases[0].structure)
        pos_value = positions.value_in_unit(unit.angstroms)
        coords = np.array(list(pos_value), dtype=np.float64)
        natoms = len(self.phases[0].structure.atoms)
        self.phases[0].structure.coordinates = coords.reshape((-1, natoms, 3))

    def _get_ligand_resname(self, filename):
        """
        Get the ligand resname
            Parameters
            ----------
       	       	filename : str
                    mol2 file.
            Returns
            -------
       	       	resname : str
                    resname of ligand.
        """
        with open(filename) as f:
            for line in f:
                if line.startswith('@<TRIPOS>'):
                    section = line[9:].strip()
                    if section == 'ATOM':
                        try:
                            resname = str(next(f).split()[7])
                        except IndexError:
                            resname = 'UNK'
                        break

        return resname

    def _system_from_pdb(self, receptor_file, **kwargs):
        """
	Creates an OpenMM system from a pdb
            Parameters
            ----------
                receptor_file : str
                    Receptor pdbfile.
            Returns
            -------
                system : openmm.System
                pdb.topology: openmm.Topology
                pdb.positions: list
                    List of atomic positions.
                total_charge: int
                    Total charge of the system.

        """
        pdb = app.PDBFile(receptor_file)
        forcefield = app.ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')
        system = forcefield.createSystem(pdb.topology, **kwargs)
        for i in range(system.getNumForces()):
            if isinstance(system.getForce(i), openmm.NonbondedForce):
                nonbonded = system.getForce(i)
                break

        charge = 0.0
        for i in range(nonbonded.getNumParticles()):
            nb_i = nonbonded.getParticleParameters(i)
            charge += nb_i[0].value_in_unit(unit.elementary_charge)
        charge = int(floor(0.5 + charge))

        return self._fix_particle_sigmas(system), pdb.topology, pdb.positions, charge

    def _system_from_amber(self, *receptor_file, **kwargs):
        """
        Creates an OpenMM system from the prmtop/inpcrd Amber files
            Parameters
            ----------
                receptor_file : list of str
                    List of filenames corresponding to the prmtop and inpcrd Amber files of the receptor.
            Returns
            -------
                system : openmm.System
                prmtop.topology: openmm.Topology
                inpcrd.positions: list
                    List of atomic positions.
                total_charge: int
                    Total charge of the system.

        """
        input = {}
        for file in receptor_file:
            name, ext = utils.parse_ligand_filename(file)
            input[ext] = file

        prmtop = app.amberprmtopfile.AmberPrmtopFile(input['.prmtop'])
        inpcrd = app.amberinpcrdfile.AmberInpcrdFile(input['.inpcrd'])
        prm = pmd.amber.AmberParm(input['.prmtop'])
        charge = int(floor(0.5 + pmd.tools.netCharge(prm).execute()))
        system = prmtop.createSystem(**kwargs)

        return self._fix_particle_sigmas(system), prmtop.topology, inpcrd.positions, charge

    def _fix_particle_sigmas(self, system):
        """
        Fix particles with zero LJ sigma
            Parameters
            ----------
                system : openmm.System
            Returns
            -------
                system : fixed openmm.System
        """
        for force in system.getForces():
            if force.__class__.__name__ == 'NonbondedForce':
                for index in range(system.getNumParticles()):
                    [charge, sigma, epsilon] = force.getParticleParameters(index)
                    if sigma / unit.nanometers == 0.0:
                        force.setParticleParameters(index, charge,
                                                   1.0*unit.angstroms, epsilon)
        return system

    def _ligand_amber_files(self, ligand_name, file):
        """
        Generates the prmtop and inpcrd files for a ligand.
        Parameters
        ----------
            ligand_name : str
                The name of the ligand.
            file : str
                Mol2 file of the ligand.
        Returns
        -------
            prmtop_filename : str
                Amber prmtop file produced by tleap.
            inpcrd_filename : str
                Amber inpcrd file produced by tleap.
        """
        gaff_mol2_filename1, frcmod_filename1 = amber.run_antechamber(ligand_name,
                                                                      file,
                                                                      resname=True,
                                                                      charge_method=None)
        source_mol2 = os.path.abspath(gaff_mol2_filename1)
        source_frcmod = os.path.abspath(frcmod_filename1)
        destination = os.path.abspath('data')
        shutil.move(source_mol2, os.path.join(destination, os.path.basename(source_mol2)))
        shutil.move(source_frcmod, os.path.join(destination, os.path.basename(source_frcmod)))
        amber.run_tleap(ligand_name, os.path.join(destination, os.path.basename(source_mol2)),
                                     os.path.join(destination, os.path.basename(source_frcmod)),
                                     f'{ligand_name}.prmtop', f'{ligand_name}.inpcrd')
        source_prmtop = os.path.abspath(f'{ligand_name}.prmtop')
        source_inpcrd = os.path.abspath(f'{ligand_name}.inpcrd')
        shutil.move(source_prmtop, os.path.join(destination, os.path.basename(source_prmtop)))
        shutil.move(source_inpcrd, os.path.join(destination, os.path.basename(source_inpcrd)))

        return os.path.join(destination, os.path.basename(source_prmtop)), os.path.join(destination, os.path.basename(source_inpcrd))



    def _solvent_amber_files(self, lig1_name, lig1_mol2, lig1_frcmod, prmtop_filename, inpcrd_filename, leaprc='leaprc.gaff'):

        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)
        handler = logging.FileHandler('tleap_solvent_phase.log')
        logger.addHandler(handler)

        #Get absolute paths for input/output
        lig1_mol2 = os.path.abspath( lig1_mol2 )
        lig1_frcmod = os.path.abspath( lig1_frcmod )

        prmtop_filename = os.path.abspath( prmtop_filename )
        inpcrd_filename = os.path.abspath( inpcrd_filename )

        #Work in a temporary directory, on hard coded filenames, to avoid any issues AMBER may have with spaces and other special characters in filenames
        with mdtraj.utils.enter_temp_directory():
            shutil.copy( lig1_mol2, 'file.mol2' )
            shutil.copy( lig1_frcmod, 'file.frcmod' )

            tleap_input = f"""
            source oldff/leaprc.ff99SB
            source {leaprc}
            loadamberparams file.frcmod
            LIG = loadmol2 file.mol2
            check LIG
            solvateBox LIG TIP3PBOX 10.0
            addIons LIG Cl- 5
            addIons LIG K+ 5
            saveamberparm LIG out.prmtop out.inpcrd
            quit
            """

            file_handle = open('tleap_commands', 'w')
            file_handle.writelines(tleap_input)
            file_handle.close()

            cmd = f'tleap -f {file_handle.name}'
            output = getoutput(cmd)
            logger.debug(output)

            #Copy back target files
            shutil.copy('out.prmtop', prmtop_filename)
            shutil.copy('out.inpcrd', inpcrd_filename)

        logfile = os.path.abspath('tleap_solvent_phase.log')
        destination = os.path.abspath('data')
        shutil.move(logfile, os.path.join(destination, os.path.basename(logfile)))

        return prmtop_filename, inpcrd_filename


    def _alchemically_modify_ligand(self, reference_system):
        """
        Creates an alchemical system.
        Returns
        -------
	    alchemical_system : simtk.openmm.AlchemicalSystem
                An alchemically modified system.
        """

        from openmmtools.alchemy import AbsoluteAlchemicalFactory, AlchemicalRegion, AlchemicalState
        factory = mmtools.alchemy.AbsoluteAlchemicalFactory(alchemical_pme_treatment='exact',
                                                           disable_alchemical_dispersion_correction=True)

        region_zero = mmtools.alchemy.AlchemicalRegion(alchemical_atoms=self.phases[0].lig1_idx ,
                                                               name='zero')
        region_one = mmtools.alchemy.AlchemicalRegion(alchemical_atoms=self.phases[0].lig2_idx ,
                                                              name='one')

        alchemical_system = factory.create_alchemical_system(reference_system,
                                                             alchemical_regions = [region_zero, region_one])
        alchemical_state_zero = mmtools.alchemy.AlchemicalState.from_system(alchemical_system,
                                                                            parameters_name_suffix = 'zero')
        alchemical_state_one = mmtools.alchemy.AlchemicalState.from_system(alchemical_system,
                                                                           parameters_name_suffix = 'one')

        return alchemical_system

    def _anneal_ligand(self, structure):
        """
        Anneal ligand interactions to clean up clashes.
        Returns
        -------
            positions : unit.Quantity
                Positions of all atoms after annealing the ligand
        """

        reference_system = copy.deepcopy(self.phases[0].system)
        guests_restraints = openmm.CustomCentroidBondForce(2, "(k/2)*distance(g1,g2)^2")
        guests_restraints.addGlobalParameter('k',
                                             100.0*unit.kilocalories_per_mole/unit.angstrom**2)
        guests_restraints.addGroup(self.phases[0].lig1_idx )
        guests_restraints.addGroup(self.phases[0].lig2_idx )
        guests_restraints.addBond([0,1], [])
        reference_system.addForce(guests_restraints)

        alchemical_system = self._alchemically_modify_ligand(reference_system)

        from openmmtools.alchemy import AlchemicalState
        alchemical_state_zero = mmtools.alchemy.AlchemicalState.from_system(alchemical_system,
                                                                            parameters_name_suffix = 'zero')
        alchemical_state_one = mmtools.alchemy.AlchemicalState.from_system(alchemical_system,
                                                                           parameters_name_suffix = 'one')

        thermodynamic_state = states.ThermodynamicState(system=alchemical_system,
                                                        temperature=300*unit.kelvin)

        composable_states = [alchemical_state_zero, alchemical_state_one]
        compound_states = states.CompoundThermodynamicState(thermodynamic_state,
                                                            composable_states=composable_states)
        sampler_state = states.SamplerState(positions=structure.positions,
                                            box_vectors=structure.topology.getPeriodicBoxVectors())
        # Anneal
        n_annealing_steps = 1000
        integrator = openmm.LangevinIntegrator(300*unit.kelvin, 90.0/unit.picoseconds,
                                               1.0*unit.femtoseconds)
        context, integrator = mmtools.cache.global_context_cache.get_context(compound_states,
                                                                             integrator)
        sampler_state.apply_to_context(context)
        compound_states.lambda_sterics_one = 0.0
        compound_states.lambda_electrostatics_one = 0.0
        compound_states.apply_to_context(context)
        print('Annealing sterics...')
        for step in progressbar.progressbar(range(n_annealing_steps)):
            compound_states.lambda_sterics_zero = float(step) / float(n_annealing_steps)
            compound_states.lambda_electrostatics_zero = 0.0
            compound_states.apply_to_context(context)
            integrator.step(1)
        print('Annealing electrostatics...')
        for step in progressbar.progressbar(range(n_annealing_steps)):
            compound_states.lambda_sterics_zero = 1.0
            compound_states.lambda_electrostatics_zero = float(step) / float(n_annealing_steps)
            compound_states.apply_to_context(context)
            integrator.step(1)
        sampler_state.update_from_context(context)

        # Compute the final energy of the system.
        final_energy = thermodynamic_state.reduced_potential(context)
        print('final alchemical energy {:8.3f}kT'.format(final_energy))

        return sampler_state.positions

    def _modify_yaml(self):
        """
        Creates a Yank yaml configuration file
        """

        file_name = 'rocsalt_system.yaml'
        config, ind, bsi = ruamel.yaml.util.load_yaml_guess_indent(open(file_name))
        instances_system = config['systems']
        instances_experiment = config['experiment']
        instances_system['relative-system'][f'ligand_dsl'] = [[f'resname {self.ligands[0].name}'],
                                                     [f'resname {self.ligands[1].name}']]
        instances_experiment['restraint'][f'restrained_ligand_atoms'] =[[f'resname {self.ligands[0].name}'],
                                                     [f'resname {self.ligands[1].name}']]
        with open(file_name, 'w') as fp:
            ruamel.yaml.round_trip_dump(config, fp,  default_flow_style=True )

class _Ligand(object):
    """
    Sets attributes to ligand

        Parameters
        ----------
            name : str
                Resname.
            charge : int
                Total charge.
            indices : list of int
                Indices of atoms of the ligand in the rocsalt.structure

    """
    def __init__(self, name, charge, indices):
        self.name = name
        self.charge = charge
        self.indices = indices

    def generate_amber_files(self, ligand_name, file):
        """
        Generates the prmtop and inpcrd files for a ligand.
        Parameters
        ----------
            ligand_name : str
                The name of the ligand.
            file : str
                Mol2 file of the ligand.
        Returns
        -------
            prmtop_filename : str
                Amber prmtop file produced by tleap.
            inpcrd_filename : str
                Amber inpcrd file produced by tleap.
        """
        gaff_mol2_filename1, frcmod_filename1 = amber.run_antechamber(ligand_name,
                                                                      file,
                                                                      resname=True,
                                                                      charge_method=None)
        source_mol2 = os.path.abspath(gaff_mol2_filename1)
        source_frcmod = os.path.abspath(frcmod_filename1)
        destination = os.path.abspath('data')
        shutil.move(source_mol2, os.path.join(destination, os.path.basename(source_mol2)))
        shutil.move(source_frcmod, os.path.join(destination, os.path.basename(source_frcmod)))
        amber.run_tleap(ligand_name, os.path.join(destination, os.path.basename(source_mol2)),
                                     os.path.join(destination, os.path.basename(source_frcmod)),
                                     f'{ligand_name}.prmtop', f'{ligand_name}.inpcrd')
        source_prmtop = os.path.abspath(f'{ligand_name}.prmtop')
        source_inpcrd = os.path.abspath(f'{ligand_name}.inpcrd')
        shutil.move(source_prmtop, os.path.join(destination, os.path.basename(source_prmtop)))
        shutil.move(source_inpcrd, os.path.join(destination, os.path.basename(source_inpcrd)))

        return os.path.join(destination, os.path.basename(source_prmtop)), os.path.join(destination, os.path.basename(source_inpcrd))



class _Phase(object):
    """
    Sets attributes to phase

        Parameters
        ----------
        structure : parmed.structure

    """
    def __init__(self, structure):

        self.structure = structure
        self.system = None

    def create_system(self):
        kwargs = { 'nonbondedMethod' : app.PME, 'constraints' : app.HBonds, 'rigidWater' : True,
        'ewaldErrorTolerance' : 1.0e-4, 'removeCMMotion' : True, 'hydrogenMass' : 3.0*unit.amu,
        'nonbondedCutoff' : 1*unit.nanometer }
        return self.structure.createSystem(**kwargs)

    def ions_atoms(self, topology):
        """
        Determines resnames and indexes of ions.
        The supported species are sodium, chlorine and potassium.

        Parameters
        ----------
            topology : openmm.Topology
        Returns
        -------
            ions : list os str
                Residue names of ions.
            ions_idx : list of int
                Indexes of ions.
        """

        ION_RESIDUE_NAMES = {'NA', 'CL', 'K'}
        ions = []
        for res in topology.residues():
            if (('-' in res.name) or ('+' in res.name) or (res.name in ION_RESIDUE_NAMES)):
                ions += [atom.index for atom in res.atoms()]

        return ions


def main():
    """Set up for a ROCSALT simulation.
    """

    parser = argparse.ArgumentParser(description='Compute relative affinities of compounds screened in ROCS')
    parser.add_argument('--ligands_filenames', dest='ligands_filenames', action='store',
                       nargs='*', help='ligands mol2 files', required=True)
    parser.add_argument('--receptor_filenames', dest='receptor_filenames', action='store',
                       nargs='*', help='receptor pdb file or prmtop/inpcrd amber files',required=True)

    args = parser.parse_args()

    # Determine the path to files input
    ligands_filenames = [os.path.abspath(i) for i in args.ligands_filenames]
    receptor_filenames = [os.path.abspath(i) for i in args.receptor_filenames]

    # Set up the OpenMM system and ParmEd structure
    rocsalt = RocsaltSystem(ligands_filenames[0], ligands_filenames[1], *receptor_filenames)

    # Serialize OpenMM system
    with open('complex_system.xml', 'w') as f:
         f.write(XmlSerializer.serialize(rocsalt.phases[0].system))
    with open('solvent_system.xml', 'w') as f:
         f.write(XmlSerializer.serialize(rocsalt.phases[1].system))
    # Write pdb
    rocsalt.phases[0].structure.write_pdb('complex_phase.pdb')
    rocsalt.phases[1].structure.write_pdb('solvent_phase.pdb')

    # Serialize ParmEd structure
    with open('complex_structure.pickle', 'wb') as file:
        pickle.dump(rocsalt.phases[0].structure, file)
    with open('solvent_structure.pickle', 'wb') as file:
        pickle.dump(rocsalt.phases[1].structure, file)
    # Edit yaml file
    rocsalt._modify_yaml()

if __name__ == "__main__":

    main()
